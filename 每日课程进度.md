# 杂记

10.116.2.55  GZYC\2010104-004

10.116.2.61

mstsc 终端打开连接虚拟机

车间制造管理系统MES 胶印 凹印  丝凸因 裁切 清分 装箱 17  入库 成品库 

后台 springmvc mybatis sqlserver vue E PDA  

ht 接口对饥接

free mybatis plugins 提高xml转mapper

RestfulToolkit 路径跳转连接

## 

# 库表结构

各个库表结构

1. mm 物资  mm_stock物资库存

2. udt_dict_products 物料信息表 enable 0不可查 1可查

3. udt_di_mdm_re_prodinfo物料中间表

4. pp pm 生产

5. wip 生产库存

6. sys_use 人员  sys_use_role 人员角色

7. sys_role 角色

8. sys_dept 部门列表：获取请购部门时专用

9. udt_di_projectinfo 项目信息表

10. logininfo登录状态  state:1在线 2注销 3交接班

11. storage 权限表

12. udt_em_equ_call_info  机器维修表   编写获取维修人员信息接口用到

    



各个模块相应的表

普通请购：

1. mm_material_normal_request_m 主表
2.  mm_material_normal_request_d  子表

# 8/11

## 工具exe使用

内部人员编写的工具生成简单的mapper.controller.service.serviceImp.vo类

1. 点击代码生成器，选择连接的数据库名字 

2. 配置包名，在那个模块并设置相应的  ---->

   1. 模块名
   2. 业务名
   3. 功能名
   4. 时间字段：daytime（在数据表中有daytime日期的字段设置默认：getdate()函数)

3. 点击生成

   ### 页面授权访问：SecurityConfig，权限放行

4. 页面授权访问：

   1. 打开目录com.gcmes.server.core.framework.config

      -->**SecurtiyConfig**

   2. 添加.antMatcher("放行的路径").anonymous

5. 服务器部署：打开xhttp:相应服务器地址，把后端class文件或者前端npm run buld生成的dist文件 添加或者覆盖到tomcat目录下的WebInf下的相应文件夹下，然后还需要杀死服务器,(先查看当前进程数)相应的进程开头很长的那个(kill)，然后重启服务,在相应的目录（/bin）打开终端 ./startup sh然后再查看日志是否启动成功    can.out 

## 数据库表设计

1. 人员，品种，机台等等都要设置id, code(20),desc(50)
2. 带号的如（大张号，冠字号）50
3. 备注 100
4. 处理措施255
5. 其他小字段都为 10





## element-UI父子级目录的一些理解

5.element-ui的数据绑定一些小基础的东西
父子级目录的展示
先声明父级目录id的变量名以及保存父级目录返回数据(list 或者map)的数组变量名（在data域），父组目录id的赋值方式是通过V-for循环遍历拿到的数据数组，然后每个数组的id再赋给父组id，接着通过父组id（：value值）得到子组id (一般数据库父子表之间都有关联的字段，用关联的字段查)最后对得到数据进行相应的操作

# 8/12

## 出现的异常信息

###  Protocol handler start failed ---Address already in user:bind



![image-20210812173800507](C:\Users\Hp\Desktop\gittxt\每日课程进度.assets\image-20210812173800507.png)

​	解决方案：

1. 打开终端控制台，
   1. 查看端口占用情况：
      1. netstat -anno |findstr "端口号8081"  ----->查看端口8081的占用情况
      2. tasklist |findstr "java"  ----->查看带有java的文件的运行情况

## 配置网路(网线的连接)

1. 配置网路(网线的连接)

   DNS：和HTTP协议一样是处于应用层的服务，提供域名到IP地址之间的解析服务

   1. 打开以太网

      ![image-20210812163321289](C:\Users\Hp\Desktop\gittxt\每日课程进度.assets\image-20210812163321289.png)

   2. 配置属性

      ![image-20210812163429620](C:\Users\Hp\Desktop\gittxt\每日课程进度.assets\image-20210812163429620.png)

   3. 设置相应的ip地址，掩码，网关 DNS

      ![image-20210812163512283](C:\Users\Hp\Desktop\gittxt\每日课程进度.assets\image-20210812163512283.png)

2. TCP（面向连接的，可靠的）、UDP（无连接的，不可靠的，常用于即时通信）TCP:三次握手—>建立一个TCP连接时需要客户端和服务器端总共发送三个包以确认连接的建立

   ######        三次握手的意义：	

   [小白文说明]: https://www.cnblogs.com/hujingnb/p/13111467.html

   

    1. 确保对方能够正常的接受数据，测试连接（在合适的时间点干合适的事情）

    2. 建立系统开销（在第二次握手的时候开辟系统资源为接受日志做准备，如果没有第三次握手，会白白浪费开辟资源，一直等待）

    3. 测试超时时间（测试请求包的往返时间，并以此计算重传时间）

    4. 安全性（对每个数据包进行编码，接收方根据编号的顺序收到的包进行重组，保证数据有序性，每一次发送的握手序列号的初始序列号进行交换，服务器接收到以后返回握手确认并且发送回来初始序列号，一定程度保证数据安全传输，随机的序列号其实还有另外一个作用,如果我们上一次连接的其中一个数据包3, 在网络中傲游了一会, 连接已经断开了, 我们又开始了新的一次数据连接, 这个时候我收到了数据包3, 就会导致生成了错误的数据序列, 而随机序列号则避免了这个问题,）

       ###### 四次挥手的意义

       在三次握手的时候, 为了接收数据并进行序列重组, 开辟了一些系统资源, 当数据发送完了, 就不用一直占着了, 早些释放, 留给别人

       ###### 总结

       1. 为了对数据进行顺序重组, 势必需要开辟系统资源. 如果没有握手的过程, 所有的请求, 都要占用资源. 而没有挥手的过程, 这些资源就不能及时释放.
       2. 为了数据的高效传输, 选用一个合理的超时重传时间是十分有必要的. 时间短了, 会导致频繁重传, 浪费网络资源. 时间长了, 就会导致整体的数据传输时间变长.
       3. 为了保证对方能够正常接收数据, 否则对方关机了, 我总不能在这一直超时重传吧.
       4. 为了保证多次连接的数据包不会引发数据错误. 通过随机的序列号, 保证了两次连接的数据包不会互相影响.

## 本地项目部署到服务器的流程

1. 本地项目部署到服务器的流程
  2. 打开xhttp软件，SSH连接进入部署的服务器ip地址
  3. 打开相应的tomcat目录（tomcat8081/tomcat8082）
  4. 了解项目前后端代码的存放地址：
     1. 前端把打包（npm run build）生成的dis目录下的文件全部替换掉服务器ROOT目录下面的文件
     2. 后端代码（gcames）进入webinf下面的class目录，现在项目只需要替换mybatis和com文件夹----一般都是由数据库生成表文件后更新服务器项目时候只需要替换这两个文件夹
  5. 进入tomcat/bin 目录，在此打开xshell
  6. 重启服务
     1. 查看进程：ps -ef|grep java ：筛选出java 的进程
     2. 杀死进程： kill -9 进程号
     3. 输出日志 kail catalina.out:输出日志最后几行
     4. 启动服务 ./startup.sh

# 8/13

1. 解读**PathHandlerServiceImpl**中的**getProdinfonumber()**通过在制品获取库存

## 模糊查询

1. mybatis 配置文件之模糊查询
   1. like concat（）：第一个参数为‘%’，第二个参数为传递过来的参数，第三个参数为‘%’
   2. 使用目的：不同与like'%?%'-->防止sql注入

## Arraylist和linkList的区别

1. Arraylist和linkList的区别
   1. 数据结构不同，动态数组arraylist和链表linklist
   2. 效率不同：随机访问时(高)：arraylist,增删查改(高)：linklist
   3. 自由度不同：ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。
   4. 主要控件开销不同：ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。

## java中数组list对象的stream流：

java中数组list对象的stream流：

1. List的Stream流操作可以简化我们的代码，减少程序运行的压力，应对上面的问题，以前的话是先查出对应的list数据，然后根据取到集合中id去查找对应的子实体中数据，接着在放入对应的集合中去，key值表示主实体的id，value值表示对应主实体id查到的结合数据，这样就会三次foreach循环组装数据，会很麻烦，当数据量大的时候，会增加程序运行的负荷，造成运行缓慢。所以，流式操作代替我们的这一堆操作，提高了代码的简易性，可维护性，可靠性，更不容易出错。

2. ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzU1NTM5Ni1jMDdjMWQ2OTZlYTE1YzZjLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwfGltYWdlVmlldzIvMi93Lzg5Ng?x-oss-process=image/format,png)

3. udtMmMaterialStocks.stream().collect(Collectors.groupingBy(UdtMnMaterialStock::getBatch))

      //返回的是以各个batch为分组的对象list<MAP>

   .foreach(batch,udtMmMaterialStockListByBatch)->{

   ​	//循环遍历了list<map<String,Object>>数组

   ***

   }

## 关于for循环和foreach循环

关于for循环和foreach循环：

1. 只是遍历集合或者数据，foreach
2. 对集合中的值进行修改，确定循环次数就要用for循环了。

## 关于BigDecimal

1. 关于BigDecimal ：处理精细的数据操作时使用
   1. 一般使用String类型的遍历初始化，否则回造成参数不准确
   2. BigDecimal bg=new BigDecimal(){new BigDecimal("0.0")}  //初始化第一个参数0.0
2. 

# 8/14

## extend和implement关系：

**Java语言并不支持多重继承，而只能继承一个类，不过我们可以使用implements来实现多个接口。**

**extends继承的父类：**不能声明为final或者定义为abstract；

i**mplements实现接口interface，用逗号分开就好**；

如：class A extends B implements C, D, E

i**nterface的引入是为了部分地提供多继承的功能**。
在interface中只需声明方法头，而将方法体留给实现的class来做。 这些实现的class的实例完全可以当作interface的实例来对待。 在interface之间也可以声明为extends（多继承）的关系。 注意一个interface可以extends多个其他interface。



### 关于implement的一些使用：

​	如果一个a类实现了（implement）另一个b类，那么这个a可以使用b中的所有变量(除了private)



## 	解读代码:UdtMnMaterizNormalRequestServiceImpl：普通请购

1. 涉及的表

   1. mm_material_normal_request_m 主表（查询请购单号，请购时间，请购部门，请购类型，请购人） 
   2. mm_material_normal_request_d子表  （根据主表的mrdid查询子表物料描述mdesc）

2. 编码思路：

   1. 首先查出主表的所有信息

   2. 进行判断，库里是否有数值，如果有，根据主表的id查子表的物料

      1. 子表物料的保存方式，也得先判断子表是否查有值

      2. 创建一个StringBuilder对象，用来保存des物料

         ```java
         int i = 0;
         StringBuilder sb = new Stringbuilder();
         //它这里 这个地方只存5条记录，多余的用......表示
         for(UdtMmMaterialNormalRequestD obj : udtMaterialNormalRequestList){ //获取每个数组里相应的对象
             //因为对象只有描述mdes不同，其他都相同（此处根据前面的查询语句，查出id相同的请购子表）
             if(StringUtils.isNoEmpty(obj.getMdes)&&i<5){
                 String meds=obj.getMdesc();
                 //根据第一个点的位置，获取第二个点的位置，根据第二个点的位置+1 截取字符串，得到结果
                 //String对象indexOf()用于查询位置，查询到的结果从0开始,使用方法有两种
                 //第一种：带一个参数的（String str）---->直接返回参数的位置
                 //第二种：带两个参数的（String str,int index）---->返回从index位置开始后，查询到的str位置
                 //String对象subString()用于截取字符串
                 //第一种：带一个参数的（int start）---->从start位置直接开始截取到字符串末尾，包括空格
                 //第二种：带两个参数的（int start,int stop）---->返回从start位置开始后直到stop位置的str内字符串
                 sb.append(mdesc.substring(mdes.indexOf(".",mdesc.indexOf(".")+1)+1).append(";").append("/n");
             i++
             }
             
         }
         ```
      
         
      
      3. aa

## 	Arrays.copyOfRange(char[]Origin,int from,int to)解析

返回一个to-from长度的数组，数组内的元素为orgin从from位置开始到to位置结束的元素，如果Orgin数组长度没有to位置（index位置 ）那么长，则给他赋值为0

### 演示代码：

```java
package niuke;

import java.util.Arrays;

public class Solution {
	public static void main(String[] args) {
		int[] n=new int[]{1};//Java中数组初始化
		int[] m=Arrays.copyOfRange(n, 1, 3);
		for(int i=0;i<m.length;i++) {
			System.out.print(m[i]+" ");
		}
	}	
}

/**返回结果 0 0 **/
/**n数组没有可以复制的，所以m数组全为0**/
--------------------------------------------------------------------
package niuke;

import java.util.Arrays;

public class Solution {
	public static void main(String[] args) {
		int[] n=new int[]{1,2,3,4,5};//Java中数组初始化
		int[] m=Arrays.copyOfRange(n, 0, 3);
		for(int i=0;i<m.length;i++) {
			System.out.print(m[i]+" ");
		}
	}	
}
//返回结果 1 2 3
/**Arrays.copyOfRange(n, 0, 3);的意思是返回一个长的为3-0=3的数组，从n数组0开始复制，由于数组n的长度大于3，因此直接从n数组0下标开始复制3个元素返回即可。
**/
————————————————

```



## 	transient，static关键字解析

如果一个类实现了**serilizable**(自动进行序列化)接口，的有些属性需要序列化，而其他属性不需要被序列化，而不需要被序列化的属性就加上transient关键字，这个属性就不会被序列化到目的地中,**可以被序列化，无法被反序列化** ，

transient用途：如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。

```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

/**
 * @description 使用transient关键字不序列化某个变量
 *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致
 *        
 * @author Alexia
 * @date  2013-10-15
 */
public class TransientTest {
    
    public static void main(String[] args) {
        
        User user = new User();
        user.setUsername("Alexia");
        user.setPasswd("123456");
        
        System.out.println("read before Serializable: ");
        System.out.println("username: " + user.getUsername());
        System.err.println("password: " + user.getPasswd());
        
        try {
            ObjectOutputStream os = new ObjectOutputStream(
                    new FileOutputStream("C:/user.txt"));
            os.writeObject(user); // 将User对象写进文件
            os.flush();
            os.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            ObjectInputStream is = new ObjectInputStream(new FileInputStream(
                    "C:/user.txt"));
            user = (User) is.readObject(); // 从流中读取User的数据
            is.close();
            
            System.out.println("\nread after Serializable: ");
            System.out.println("username: " + user.getUsername());
            System.err.println("password: " + user.getPasswd());
            
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

class User implements Serializable {
    private static final long serialVersionUID = 8294180014912103005L;  
    
    private String username;
    private transient String passwd;
    
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    public String getPasswd() {
        return passwd;
    }
    
    public void setPasswd(String passwd) {
        this.passwd = passwd;
    }

}
/**输出结果
read before Serializable: 
username: Alexia
password: 123456

read after Serializable: 
username: Alexia
password: null

**/
```

一个被static修饰的变量，无论是否实现**Serilizable**接口，都无法进行序列化和反序列化，他之所以在序列化后还能被读取的原因在于他是在读取的JVM(java虚拟机)中的static值，例子如下：

```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

/**
 * @description 使用transient关键字不序列化某个变量
 *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致
 *        
 * @author Alexia
 * @date  2013-10-15
 */
public class TransientTest {
    
    public static void main(String[] args) {
        
        User user = new User();
        user.setUsername("Alexia");
        user.setPasswd("123456");
        
        System.out.println("read before Serializable: ");
        System.out.println("username: " + user.getUsername());
        System.err.println("password: " + user.getPasswd());
        
        try {
            ObjectOutputStream os = new ObjectOutputStream(
                    new FileOutputStream("C:/user.txt"));
            os.writeObject(user); // 将User对象写进文件
            os.flush();
            os.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            // 在反序列化之前改变username的值
            User.username = "jmwang";
            
            ObjectInputStream is = new ObjectInputStream(new FileInputStream(
                    "C:/user.txt"));
            user = (User) is.readObject(); // 从流中读取User的数据
            is.close();
            
            System.out.println("\nread after Serializable: ");
            System.out.println("username: " + user.getUsername());
            System.err.println("password: " + user.getPasswd());
            
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

class User implements Serializable {
    private static final long serialVersionUID = 8294180014912103005L;  
    
    public static String username;
    private transient String passwd;
    
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    public String getPasswd() {
        return passwd;
    }
    
    public void setPasswd(String passwd) {
        this.passwd = passwd;
    }

}
/**
read before Serializable: 
username: Alexia
password: 123456

read after Serializable: 
username: jmwang
password: null
**/

```

如果一个类实现了**Externalizable**(手动进行序列化)接口，这个类里面的属性无论是否用transient修饰 都需要手动调用writeExternal和readExternal对象才会被序列号和反序列化

```java
import java.io.Externalizable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;

/**
 * @descripiton Externalizable接口的使用
 * 
 * @author Alexia
 * @date 2013-10-15
 *
 */
public class ExternalizableTest implements Externalizable {

    private transient String content = "是的，我将会被序列化，不管我是否被transient关键字修饰";

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(content);
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException,
            ClassNotFoundException {
        content = (String) in.readObject();
    }

    public static void main(String[] args) throws Exception {
        
        ExternalizableTest et = new ExternalizableTest();
        ObjectOutput out = new ObjectOutputStream(new FileOutputStream(
                new File("test")));
        out.writeObject(et);

        ObjectInput in = new ObjectInputStream(new FileInputStream(new File(
                "test")));
        et = (ExternalizableTest) in.readObject();
        System.out.println(et.content);

        out.close();
        in.close();
    }
}
/**输出结果 : 是的，我将会被序列化，不管我是否被transient关键字修饰**/
```

​				**transient小结：**
1. 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。
2. transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。
3. 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。

##     StringBuilder/StringBuffer解析

1. 类结构:都是继承同一个抽象父类AbstractStringBuilder

   ![img](https://segmentfault.com/img/remote/1460000017909553?w=480&h=230)

2. 区别：

   1. 线程安全问题

      StringBuider线程不安全，StringBuffer线程安全（所有的方法体里面加了Synchronized）

      ```java
      /**
      StringBuffer
      **/
      @Override
      public synchronized StringBuffer append(String str) {
          toStringCache = null;
          super.append(str);
          return this;
      }
      ```

   2. 缓冲区

      ```java
      /**
      StringBuffer
      **/
      private transient char[] toStringCache;
      
      @Override
      public synchronized String toString() {
          if (toStringCache == null) {
              toStringCache = Arrays.copyOfRange(value, 0, count);
          }
          return new String(toStringCache, true);
      }
      ```

      ```java
      /**
      StringBuilder
      **/
      @Override
      public String toString() {
          // Create a copy, don't share the array
          return new String(value, 0, count);
      }
      ```

      从上面可以看出（需要点进源码查看）

      StringBuffer每次获取toString都会从缓冲区中toStringCache中构造一个字符串

      StringBuilder则每次都需要复制一个字符数组，再构造一个字符串

   3. 性能：StringBuilder(未加锁)性能远大于StringBuffer

   4. 小结：StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合。

3. 

# 8/15

## git 学习：

- **工作区：**就是你在电脑里能看到的目录。

- **暂存区：**英文叫 stage 或 index。一般存放在 **.git** 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。

- **版本库：**工作区有一个隐藏目录 **.git**，这个不算工作区，而是 Git 的版本库。

  

  **基本操作**

1. 创建文件夹（gittest），初始化文件夹生成.git（.git相当于版本库）

   ```bash
   git init
   ```

2. 添加远程版本仓库，需要和远程仓库(例如远程仓库叫做savenote)的名字保持一致

   ```bash
   git remote add savenote https://xxx.git
   ```

   1. 查看远程版本库的详细信息（后面不加show时，显示所有添加的远程仓库）

      ```bash
      git remote show xxxx
      ```

   2. 重命名远程版本库

      ```bash
      git remote rename old_name new_name
      ```

   3. 删除远程版本库

      ```bash
      git remote rm xxxx
      ```

3. 拉取远程仓库文件到本地,最后的**master**是远程仓库的分支名,此时得到远程项目文件的全部内容

   在每个新建的文件夹里，都要先同步远程仓库，即一下这一条命令，最后才能进行push操作
   
   ```bash
   git pull savenote master
   ```
   
4. 回退上一个上传的版本信息

   ```
   git reset --hard head
   ```

   

### 文件的上传：

1. 在需要上传的文件目录下面先git init 初始化版本库

   ```bash
   git init
   ```

   查看工作区状态

   ```bash
   git status
   ```

2. 把文件添加到暂存区/缓存区

   ```bash
   git add xxx
   ```

3. 把文件添加到版本库或者本地仓库，并且为此次操作添加信息

   ```bash
   git commit -m 信息
   ```

4. 把代码提交到远程仓库：有两种情况进行：

   1. 已连接远程仓库(假设仓库名字为savenote)：具体的连接方法看上方基本操作

      ```java
      git push -u savenote master
      ```

   2. 未连接远程仓库的情况（git push 加上项目的 clone 地址+分支名）

      ```
      git push https://xxxx.git master
      ```

   

### github上项目文件的删除

1. 最详细的方法：（在没有github上全部文件的情况下，如果有，请直接跳到第4步：）

   ***（原理就是第四部删除缓存的相应文件，然后更新到仓库）***

   先创建文件夹并初始化

   ```bash
   git init
   ```

2. 连接远程项目仓库(例如仓库为savenote)：

   ```
   git remote add savenote https://xxx.git
   ```

3. 拉去远程仓库的所有文件：

   ```bash
   git pull savenote master
   ```

4. 删除相应本地磁盘的文件：(XXX为对应的文件)

   ```bash
   git rm -r --cache XXX
   ```

5. 提交到本地仓库/版本库，并显示提交信息

   ```bash
   git commit -m 信息
   ```

6. 提交到远程仓库：(此处后，删除成功)

   ```
   git push -u savenote master
   ```

   

# 8/16

## idea 添加svn 上传按钮：

1. file-->setting--->version control--->Subversion选择安装的相应的svn或者git

2. 添加按钮commit和update 

   file-->setting--->version control

   ![image-20210816100450806](C:\Users\Hp\Desktop\gittxt\每日课程进度.assets\image-20210816100450806.png)

   ![image-20210816100513632](C:\Users\Hp\Desktop\gittxt\每日课程进度.assets\image-20210816100513632.png)

   apply 完成

## 前端学习： src/views/supplies/editTable.vue

1. 测试方法console.log('response=>',response.rows)



# 8/17

## 前端学习： src/views/comprePicAppTabel.vue --->component/ MaterialInfo index.vue

scope.row 相当于获取当前行数据

Object.trim():去除两端空格，无论有多少行空格

handleAdd（row）添加按钮：

1. 现在要找查询按钮看看如何获取输入框参数（handleQuery）:

## WebService 配置

1. 开启服务：包路径（core.framework.config.WebServiceConfig-->*配置文件@Configuration*）:

   ```java
   @Configuration
   public class WebServiceConfig{
       @AutoWired
       private Bus bus;
       @Autowired
       private IXXXService xxxService;
   
       @Bean
       public Endpoint endpointXXXService(){
           EndpointImpl endpoint = new EndpointImpl(bus,XXXService);
           endpoint.publish("/xxx");//接口地址
           return endpoint;
       }
   }
   ```

2. 编写xxxService和xxxServiceImpl:

   ```java
   @WebService(targetNamespace = "随便写，一般是项目全路径名")//映射在wsdl文件中的xmls:tns中
   public interface IXXXService{
       @WebMethod //对外公开一个方法
       public String XXX(xxx)thorws Exception;
   }
   ```

   ```java
   @WebService(serviceName ="IXXXService"， targetNamespace="对应IXXXService中的相同属性路径"，endpointInterface = "IXXXService全路径名称，具体的位置")
   public class XXXServiceImpl implements IXXXService{
       private Logger logger = LoggerFactory.getLogger(XXXServiceImpl.class)
   	@Override
   	public String XXX(xxx)throws Exception(){
   	
   	}
   }
   ```

3. 

# 8/18

## WebService 服务器接口传参类型转换

1. Json(String)转Object--> JSONObject.parseObject(String,实体类名.class)

2. Object转Json-->JSONObject.toJSONString(Object);

   1. 此处的Object可以时单个实体类，也可以时list集合

   2. 在写入list集合的时候有几个注意点：因为返回的是Json字符串，所以，要使用不同的对象，不能使用同一个对象进行赋值操作并写入list，这样会导致打印的Json数据只能显示第一个对象,原因是：同一个对象的hashCode()哈希地址相同，用toString的时候打印是相同的，但是用json解析的时候就不一样了，会显示异常的数据{"$ref":"$[0]"},{"$ref":"$[0]"}]

      $ref 标示的，下面介绍一些引用的描述 ​

      "$ref":".." 上一级 "​

      "$ref":"@" 当前对象，也就是自引用 "​

      "$@ref$":$" 根对象 "

      "$ref":"#.children.0" 基于路径的引用，相当于 root.getChildren().get(0)，具体解析过程看如下

      1. 代码里面出现了不一样的json，数据插入都是成功的，为什么用f***astjson***一解析就错误了！

         然后我分析了他的代码，然后模拟了它的出错信息！

         结果如下：

         ```bash
         数组打印：[User(name=李白, age=20), User(name=李白, age=20), User(name=李白, age=20)]
         json打印：[{"age":"20","name":"李白"},{"$ref":"$[0]"},{"$ref":"$[0]"}]
         ```

         模拟过程：

         首先实体类：

         @Data

         ```java
         public class User {
             private String name;
             private String age;
         }
         ```

         然后测试类：

         ```java
         @Test
             public void ceshi(){
                 User user = new User();
                 List<User> list = new ArrayList<User>();
                 for (int i = 0; i <3 ; i++) {
                     user.setName("李白");
                     user.setAge("20");
                     list.add(user);
                 }
                 System.out.println(list);
                 for (User user1 : list) {
                     System.out.println("user对象"+user1);
                     System.out.println("哈希地址"+user1.hashCode());
                     System.out.println("该对象的json"+JSON.toJSONString(user1));
                 }
                 String string = JSON.toJSONString(list);
                 System.out.println(string);
             }
         ```

         原因是：

         打印结果：

         ```bash
         [User(name=李白, age=20), User(name=李白, age=20), User(name=李白, age=20)]
         user对象User(name=李白, age=20)
         哈希地址50164460
         该对象的json{"age":"20","name":"李白"}
         user对象User(name=李白, age=20)
         哈希地址50164460
         该对象的json{"age":"20","name":"李白"}
         user对象User(name=李白, age=20)
         哈希地址50164460
         该对象的json{"age":"20","name":"李白"}
         [{"age":"20","name":"李白"},{"$ref":"$[0]"},{"$ref":"$[0]"}]
         ```

         用同一个对象，进行赋值插入list集合中，然后，集合中虽然是不同对象，但是对象的hashcode是同样，所以用toString打印是显示不同，但是用json解析就不一样了！

         ### 解决方法

         1. 重新new 一个实体类，引用不同的hashcode

         2. 禁止循环引用

            ```java
            JSON.toJSONString(this,SerializerFeature.DisableCircularReferenceDetect)
            ```

## SpringBoot中@Configuration和@Bean原理：

@Configuration：相当于spring配置文件中的<beans>标签 @Bean：相当于<bean>标签

​			由于第三方库中的类无法使用@Component、@Service、@Resposity、@Controller注入Spring容器，所以，采用的是			@Bean的方式进行解决，在xml中<bean>标签还能给自定义的类使用

@Bean 是一个方法级上的注解，主要用在@Configuration注解类里，也可以用在@Component注解类里，xml配置中添加的bean的id为方法名

## esb工具类（business/tool/gen/util）：XmlUtils解析：

```java
package com.jluzh.rentalsystem;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.Source;
import javax.xml.transform.sax.SAXSource;
import java.io.StringReader;
import java.io.StringWriter;

/****
 *  处理xml和bean之间相互转换的类
 */
public class XmlUtils {
    public static String beanToXml(Object obj,Class<?> load) throws JAXBException {
        //创建一个JAXBContext实例
        JAXBContext context = JAXBContext.newInstance(load);
        //创建一个处理java转为xml数据格式的marsheller对象
        //Marshaller类负责管理将Java内容树序列化为XML数据的过程。 它提供了基本的编组方法：
        Marshaller marshaller = context.createMarshaller();
//        用于指定编组的XML数据是否使用换行符和缩进格式化的属性的名称
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,true);
//        指定xml输出编码的属性名称
        marshaller.setProperty(Marshaller.JAXB_ENCODING,"UTF-8");
        //在字符串缓冲区中收集其输出的字符流，然后可以用于构造字符串。
        StringWriter writer = new StringWriter();
        //将一个obj内容树，组织成String
        marshaller.marshal(obj,writer);
        //StringWriter转String
        String str = writer.toString().replace("standlone=\"yes\"", "''");
        return str;
    }
    public static String xmlToBean(String xml , Class<?> load) throws Exception {
        JAXBContext context = JAXBContext.newInstance(load);
        //Unmarshaller类管理将XML数据反序列化为新创建的Java内容树的过程，
        // 可选地在未编组的情况下验证XML数据。
        // 它为许多不同的输入类型提供了未装模式的超载。
        Unmarshaller unmarshaller = context.createUnmarshaller();
        Source source = turnSource(xml);
        return null;
    }
    public static Source turnSource(String xml) throws Exception {
        //创建一个字符流，其源是个字符串
        StringReader reader = new StringReader(xml);
        //SAXParserFactory：定义工厂API，使应用程序能够配置和获取基于SAX的解析器来解析XML文档。
        SAXParserFactory sax = SAXParserFactory.newInstance();
        //忽略命名空间对数据封装的影响
        sax.setNamespaceAware(false);
        //根据工厂对象sax创建一个SAXParaser对象，根据这个对象，获取该类封装的XMLReader
        XMLReader xmlReader = sax.newSAXParser().getXMLReader();

        //最后返回new SAXSource对象,创建一个SAXSource ，使用XMLReader和SAX的InputSource。
        //参数
        //reader - 用于解析的XMLReader。
        //inputSource - 一个SAX输入源引用，必须是非空的，并且将被传递给读者解析方法
        return new SAXSource(xmlReader,new InputSource(reader));
    }

}

```



# #
