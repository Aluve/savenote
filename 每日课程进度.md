10.116.2.55  GZYC\2010104-004

车间制造管理系统MES 胶印 凹印  丝凸因 裁切 清分 装箱 17  入库 成品库 

10.116.2.61

后台 springmvc mybatis sqlserver vue E PDA  

ht 接口对接

## 

# 库表结构

各个库表结构

1. mm 物资  mm_stock物资库存

2. pp pm 生产

3. wip 生产库存

4. sys_use 人员  sys_use_role 人员角色

5. sys_role 角色

6. sys_dept 部门列表：获取请购部门时专用

7. udt_di_projectinfo 项目信息表

8. logininfo登录状态  state:1在线 2注销 3交接班

9. storage 权限表

10. 

    



各个模块相应的表

普通请购：

1. mm_material_normal_request_m 主表
2.  mm_material_normal_request_d  子表

# 8/11

## 工具exe使用

内部人员编写的工具生成简单的mapper.controller.service.serviceImp.vo类

1. 点击代码生成器，选择连接的数据库名字 

2. 配置包名，在那个模块并设置相应的  ---->

   1. 模块名
   2. 业务名
   3. 功能名
   4. 时间字段：daytime（在数据表中有daytime日期的字段设置默认：getdate()函数)

3. 点击生成

   ### 页面授权访问：SecurityConfig，权限放行

4. 页面授权访问：

   1. 打开目录com.gcmes.server.core.framework.config

      -->**SecurtiyConfig**

   2. 添加.antMatcher("放行的路径").anonymous

5. 服务器部署：打开xhttp:相应服务器地址，把后端class文件或者前端npm run buld生成的dist文件 添加或者覆盖到tomcat目录下的WebInf下的相应文件夹下，然后还需要杀死服务器,(先查看当前进程数)相应的进程开头很长的那个(kill)，然后重启服务,在相应的目录（/bin）打开终端 ./startup sh然后再查看日志是否启动成功    can.out 

## 数据库表设计

1. 人员，品种，机台等等都要设置id, code(20),desc(50)
2. 带号的如（大张号，冠字号）50
3. 备注 100
4. 处理措施255
5. 其他小字段都为 10





## element-UI父子级目录的一些理解

5.element-ui的数据绑定一些小基础的东西
父子级目录的展示
先声明父级目录id的变量名以及保存父级目录返回数据(list 或者map)的数组变量名（在data域），父组目录id的赋值方式是通过V-for循环遍历拿到的数据数组，然后每个数组的id再赋给父组id，接着通过父组id（：value值）得到子组id (一般数据库父子表之间都有关联的字段，用关联的字段查)最后对得到数据进行相应的操作

# 8/12

## 出现的异常信息

###  Protocol handler start failed ---Address already in user:bind



![image-20210812173800507](C:\Users\Hp\Desktop\每日课程进度.assets\image-20210812173800507.png)

​	解决方案：

1. 打开终端控制台，
   1. 查看端口占用情况：
      1. netstat -anno |findstr "端口号8081"  ----->查看端口8081的占用情况
      2. tasklist |findstr "java"  ----->查看带有java的文件的运行情况

## 配置网路(网线的连接)

1. 配置网路(网线的连接)

   DNS：和HTTP协议一样是处于应用层的服务，提供域名到IP地址之间的解析服务

   1. 打开以太网

      ![image-20210812163321289](C:\Users\Hp\Desktop\gittxt\每日课程进度.assets\image-20210812163321289.png)

   2. 配置属性

      ![image-20210812163429620](C:\Users\Hp\Desktop\gittxt\每日课程进度.assets\image-20210812163429620.png)

   3. 设置相应的ip地址，掩码，网关 DNS

      ![image-20210812163512283](C:\Users\Hp\Desktop\gittxt\每日课程进度.assets\image-20210812163512283.png)

2. TCP（面向连接的，可靠的）、UDP（无连接的，不可靠的，常用于即时通信）TCP:三次握手—>建立一个TCP连接时需要客户端和服务器端总共发送三个包以确认连接的建立

   ######        三次握手的意义：	

   [小白文说明]: https://www.cnblogs.com/hujingnb/p/13111467.html

   

    1. 确保对方能够正常的接受数据，测试连接（在合适的时间点干合适的事情）

    2. 建立系统开销（在第二次握手的时候开辟系统资源为接受日志做准备，如果没有第三次握手，会白白浪费开辟资源，一直等待）

    3. 测试超时时间（测试请求包的往返时间，并以此计算重传时间）

    4. 安全性（对每个数据包进行编码，接收方根据编号的顺序收到的包进行重组，保证数据有序性，每一次发送的握手序列号的初始序列号进行交换，服务器接收到以后返回握手确认并且发送回来初始序列号，一定程度保证数据安全传输，随机的序列号其实还有另外一个作用,如果我们上一次连接的其中一个数据包3, 在网络中傲游了一会, 连接已经断开了, 我们又开始了新的一次数据连接, 这个时候我收到了数据包3, 就会导致生成了错误的数据序列, 而随机序列号则避免了这个问题,）

       ###### 四次挥手的意义

       在三次握手的时候, 为了接收数据并进行序列重组, 开辟了一些系统资源, 当数据发送完了, 就不用一直占着了, 早些释放, 留给别人

       ###### 总结

       1. 为了对数据进行顺序重组, 势必需要开辟系统资源. 如果没有握手的过程, 所有的请求, 都要占用资源. 而没有挥手的过程, 这些资源就不能及时释放.
       2. 为了数据的高效传输, 选用一个合理的超时重传时间是十分有必要的. 时间短了, 会导致频繁重传, 浪费网络资源. 时间长了, 就会导致整体的数据传输时间变长.
       3. 为了保证对方能够正常接收数据, 否则对方关机了, 我总不能在这一直超时重传吧.
       4. 为了保证多次连接的数据包不会引发数据错误. 通过随机的序列号, 保证了两次连接的数据包不会互相影响.

## 本地项目部署到服务器的流程

1. 本地项目部署到服务器的流程
  2. 打开xhttp软件，SSH连接进入部署的服务器ip地址
  3. 打开相应的tomcat目录（tomcat8081/tomcat8082）
  4. 了解项目前后端代码的存放地址：
     1. 前端把打包（npm run build）生成的dis目录下的文件全部替换掉服务器ROOT目录下面的文件
     2. 后端代码（gcames）进入webinf下面的class目录，现在项目只需要替换mybatis和com文件夹----一般都是由数据库生成表文件后更新服务器项目时候只需要替换这两个文件夹
  5. 进入tomcat/bin 目录，在此打开xshell
  6. 重启服务
     1. 查看进程：ps -ef|grep java ：筛选出java 的进程
     2. 杀死进程： kill -9 进程号
     3. 输出日志 kail catalina.out:输出日志最后几行
     4. 启动服务 ./startup.sh

# 8/13

1. 解读**PathHandlerServiceImpl**中的**getProdinfonumber()**通过在制品获取库存

## 模糊查询

1. mybatis 配置文件之模糊查询
   1. like concat（）：第一个参数为‘%’，第二个参数为传递过来的参数，第三个参数为‘%’
   2. 使用目的：不同与like'%?%'-->防止sql注入

## Arraylist和linkList的区别

1. Arraylist和linkList的区别
   1. 数据结构不同，动态数组arraylist和链表linklist
   2. 效率不同：随机访问时(高)：arraylist,增删查改(高)：linklist
   3. 自由度不同：ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。
   4. 主要控件开销不同：ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。

## java中数组list对象的stream流：

java中数组list对象的stream流：

1. List的Stream流操作可以简化我们的代码，减少程序运行的压力，应对上面的问题，以前的话是先查出对应的list数据，然后根据取到集合中id去查找对应的子实体中数据，接着在放入对应的集合中去，key值表示主实体的id，value值表示对应主实体id查到的结合数据，这样就会三次foreach循环组装数据，会很麻烦，当数据量大的时候，会增加程序运行的负荷，造成运行缓慢。所以，流式操作代替我们的这一堆操作，提高了代码的简易性，可维护性，可靠性，更不容易出错。

2. ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzU1NTM5Ni1jMDdjMWQ2OTZlYTE1YzZjLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwfGltYWdlVmlldzIvMi93Lzg5Ng?x-oss-process=image/format,png)

3. udtMmMaterialStocks.stream().collect(Collectors.groupingBy(UdtMnMaterialStock::getBatch))

      //返回的是以各个batch为分组的对象list<MAP>

   .foreach(batch,udtMmMaterialStockListByBatch)->{

   ​	//循环遍历了list<map<String,Object>>数组

   ***

   }

## 关于for循环和foreach循环

关于for循环和foreach循环：

1. 只是遍历集合或者数据，foreach
2. 对集合中的值进行修改，确定循环次数就要用for循环了。

## 关于BigDecimal

1. 关于BigDecimal ：处理精细的数据操作时使用
   1. 一般使用String类型的遍历初始化，否则回造成参数不准确
   2. BigDecimal bg=new BigDecimal(){new BigDecimal("0.0")}  //初始化第一个参数0.0
2. 

# 8/14

## extend和implement关系：

**Java语言并不支持多重继承，而只能继承一个类，不过我们可以使用implements来实现多个接口。**

**extends继承的父类：**不能声明为final或者定义为abstract；

i**mplements实现接口interface，用逗号分开就好**；

如：class A extends B implements C, D, E

i**nterface的引入是为了部分地提供多继承的功能**。
在interface中只需声明方法头，而将方法体留给实现的class来做。 这些实现的class的实例完全可以当作interface的实例来对待。 在interface之间也可以声明为extends（多继承）的关系。 注意一个interface可以extends多个其他interface。



### 关于implement的一些使用：

​	如果一个a类实现了（implement）另一个b类，那么这个a可以使用b中的所有变量(除了private)



## 	解读代码:UdtMnMaterizNormalRequestServiceImpl：普通请购

1. 涉及的表

   1. mm_material_normal_request_m 主表（查询请购单号，请购时间，请购部门，请购类型，请购人） 
   2. mm_material_normal_request_d子表  （根据主表的mrdid查询子表物料描述mdesc）

2. 编码思路：

   1. 首先查出主表的所有信息

   2. 进行判断，库里是否有数值，如果有，根据主表的id查子表的物料

      1. 子表物料的保存方式，也得先判断子表是否查有值

      2. 创建一个StringBuilder对象，用来保存des物料

         ```java
         int i = 0;
         StringBuilder sb = new Stringbuilder();
         //它这里 这个地方只存5条记录，多余的用......表示
         for(UdtMmMaterialNormalRequestD obj : udtMaterialNormalRequestList){ //获取每个数组里相应的对象
             //因为对象只有描述mdes不同，其他都相同（此处根据前面的查询语句，查出id相同的请购子表）
             if(StringUtils.isNoEmpty(obj.getMdes)&&i<5){
                 String meds=obj.getMdesc();
                 //根据第一个点的位置，获取第二个点的位置，根据第二个点的位置+1 截取字符串，得到结果
                 //String对象indexOf()用于查询位置，查询到的结果从0开始,使用方法有两种
                 //第一种：带一个参数的（String str）---->直接返回参数的位置
                 //第二种：带两个参数的（String str,int index）---->返回从index位置开始后，查询到的str位置
                 //String对象subString()用于截取字符串
                 //第一种：带一个参数的（int start）---->从start位置直接开始截取到字符串末尾，包括空格
                 //第二种：带两个参数的（int start,int stop）---->返回从start位置开始后直到stop位置的str内字符串
                 sb.append(mdesc.substring(mdes.indexOf(".",mdesc.indexOf(".")+1)+1).append(";").append("/n");
             i++
             }
             
         }
         ```
      
         
      
      3. aa

## 	Arrays.copyOfRange(char[]Origin,int from,int to)解析

返回一个to-from长度的数组，数组内的元素为orgin从from位置开始到to位置结束的元素，如果Orgin数组长度没有to位置（index位置 ）那么长，则给他赋值为0

### 演示代码：

```java
package niuke;

import java.util.Arrays;

public class Solution {
	public static void main(String[] args) {
		int[] n=new int[]{1};//Java中数组初始化
		int[] m=Arrays.copyOfRange(n, 1, 3);
		for(int i=0;i<m.length;i++) {
			System.out.print(m[i]+" ");
		}
	}	
}

/**返回结果 0 0 **/
/**n数组没有可以复制的，所以m数组全为0**/
--------------------------------------------------------------------
package niuke;

import java.util.Arrays;

public class Solution {
	public static void main(String[] args) {
		int[] n=new int[]{1,2,3,4,5};//Java中数组初始化
		int[] m=Arrays.copyOfRange(n, 0, 3);
		for(int i=0;i<m.length;i++) {
			System.out.print(m[i]+" ");
		}
	}	
}
//返回结果 1 2 3
/**Arrays.copyOfRange(n, 0, 3);的意思是返回一个长的为3-0=3的数组，从n数组0开始复制，由于数组n的长度大于3，因此直接从n数组0下标开始复制3个元素返回即可。
**/
————————————————

```



## 	transient，static关键字解析

如果一个类实现了**serilizable**(自动进行序列化)接口，的有些属性需要序列化，而其他属性不需要被序列化，而不需要被序列化的属性就加上transient关键字，这个属性就不会被序列化到目的地中,**可以被序列化，无法被反序列化** ，

transient用途：如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。

```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

/**
 * @description 使用transient关键字不序列化某个变量
 *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致
 *        
 * @author Alexia
 * @date  2013-10-15
 */
public class TransientTest {
    
    public static void main(String[] args) {
        
        User user = new User();
        user.setUsername("Alexia");
        user.setPasswd("123456");
        
        System.out.println("read before Serializable: ");
        System.out.println("username: " + user.getUsername());
        System.err.println("password: " + user.getPasswd());
        
        try {
            ObjectOutputStream os = new ObjectOutputStream(
                    new FileOutputStream("C:/user.txt"));
            os.writeObject(user); // 将User对象写进文件
            os.flush();
            os.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            ObjectInputStream is = new ObjectInputStream(new FileInputStream(
                    "C:/user.txt"));
            user = (User) is.readObject(); // 从流中读取User的数据
            is.close();
            
            System.out.println("\nread after Serializable: ");
            System.out.println("username: " + user.getUsername());
            System.err.println("password: " + user.getPasswd());
            
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

class User implements Serializable {
    private static final long serialVersionUID = 8294180014912103005L;  
    
    private String username;
    private transient String passwd;
    
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    public String getPasswd() {
        return passwd;
    }
    
    public void setPasswd(String passwd) {
        this.passwd = passwd;
    }

}
/**输出结果
read before Serializable: 
username: Alexia
password: 123456

read after Serializable: 
username: Alexia
password: null

**/
```

一个被static修饰的变量，无论是否实现**Serilizable**接口，都无法进行序列化和反序列化，他之所以在序列化后还能被读取的原因在于他是在读取的JVM(java虚拟机)中的static值，例子如下：

```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

/**
 * @description 使用transient关键字不序列化某个变量
 *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致
 *        
 * @author Alexia
 * @date  2013-10-15
 */
public class TransientTest {
    
    public static void main(String[] args) {
        
        User user = new User();
        user.setUsername("Alexia");
        user.setPasswd("123456");
        
        System.out.println("read before Serializable: ");
        System.out.println("username: " + user.getUsername());
        System.err.println("password: " + user.getPasswd());
        
        try {
            ObjectOutputStream os = new ObjectOutputStream(
                    new FileOutputStream("C:/user.txt"));
            os.writeObject(user); // 将User对象写进文件
            os.flush();
            os.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            // 在反序列化之前改变username的值
            User.username = "jmwang";
            
            ObjectInputStream is = new ObjectInputStream(new FileInputStream(
                    "C:/user.txt"));
            user = (User) is.readObject(); // 从流中读取User的数据
            is.close();
            
            System.out.println("\nread after Serializable: ");
            System.out.println("username: " + user.getUsername());
            System.err.println("password: " + user.getPasswd());
            
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

class User implements Serializable {
    private static final long serialVersionUID = 8294180014912103005L;  
    
    public static String username;
    private transient String passwd;
    
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    public String getPasswd() {
        return passwd;
    }
    
    public void setPasswd(String passwd) {
        this.passwd = passwd;
    }

}
/**
read before Serializable: 
username: Alexia
password: 123456

read after Serializable: 
username: jmwang
password: null
**/

```

如果一个类实现了**Externalizable**(手动进行序列化)接口，这个类里面的属性无论是否用transient修饰 都需要手动调用writeExternal和readExternal对象才会被序列号和反序列化

```java
import java.io.Externalizable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;

/**
 * @descripiton Externalizable接口的使用
 * 
 * @author Alexia
 * @date 2013-10-15
 *
 */
public class ExternalizableTest implements Externalizable {

    private transient String content = "是的，我将会被序列化，不管我是否被transient关键字修饰";

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(content);
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException,
            ClassNotFoundException {
        content = (String) in.readObject();
    }

    public static void main(String[] args) throws Exception {
        
        ExternalizableTest et = new ExternalizableTest();
        ObjectOutput out = new ObjectOutputStream(new FileOutputStream(
                new File("test")));
        out.writeObject(et);

        ObjectInput in = new ObjectInputStream(new FileInputStream(new File(
                "test")));
        et = (ExternalizableTest) in.readObject();
        System.out.println(et.content);

        out.close();
        in.close();
    }
}
/**输出结果 : 是的，我将会被序列化，不管我是否被transient关键字修饰**/
```

​				**transient小结：**
1. 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。
2. transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。
3. 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。

##     StringBuilder/StringBuffer解析

1. 类结构:都是继承同一个抽象父类AbstractStringBuilder

   ![img](https://segmentfault.com/img/remote/1460000017909553?w=480&h=230)

2. 区别：

   1. 线程安全问题

      StringBuider线程不安全，StringBuffer线程安全（所有的方法体里面加了Synchronized）

      ```java
      /**
      StringBuffer
      **/
      @Override
      public synchronized StringBuffer append(String str) {
          toStringCache = null;
          super.append(str);
          return this;
      }
      ```

   2. 缓冲区

      ```java
      /**
      StringBuffer
      **/
      private transient char[] toStringCache;
      
      @Override
      public synchronized String toString() {
          if (toStringCache == null) {
              toStringCache = Arrays.copyOfRange(value, 0, count);
          }
          return new String(toStringCache, true);
      }
      ```

      ```java
      /**
      StringBuilder
      **/
      @Override
      public String toString() {
          // Create a copy, don't share the array
          return new String(value, 0, count);
      }
      ```

      从上面可以看出（需要点进源码查看）

      StringBuffer每次获取toString都会从缓冲区中toStringCache中构造一个字符串

      StringBuilder则每次都需要复制一个字符数组，再构造一个字符串

   3. 性能：StringBuilder(未加锁)性能远大于StringBuffer

   4. 小结：StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合。

3. 

# # 

​	
